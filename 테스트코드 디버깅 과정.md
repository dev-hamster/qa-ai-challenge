# 테스트케이스 디버깅

> 테스트케이스 디버깅 일부 과정입니다. Playwright에서 제공하는 에러와 관련된 프롬프트를 사용해 해결했습니다.

**You:**

테스트 어떻게 실행해

---

**ChatGPT:**

Playwright 테스트는 크게 두 가지 방식으로 실행할 수 있어요.  
(가이드에서 보여준 구조를 기준으로 설명드릴게요)

---

1. 환경 준비

---

1. **Playwright 설치**

   ```bash
   npm init -y
   npm install -D @playwright/test
   ```

2. **브라우저 바이너리 설치** (처음 한 번만 실행)

   ```bash
   npx playwright install
   ```

3. **프로젝트 구조 예시**

   ```
   tests/
     login.success.spec.ts
     fixtures/
       users.ts
   playwright.config.ts
   ```

---

2. 테스트 실행 방법

---

### (1) 전체 테스트 실행

```bash
npx playwright test
```

### (2) 특정 파일만 실행

```bash
npx playwright test tests/login.success.spec.ts
```

### (3) 특정 테스트 이름만 실행

```bash
npx playwright test -g "올바른 아이디/비밀번호"
```

### (4) 브라우저 지정 실행

```bash
npx playwright test --project=chromium
npx playwright test --project=firefox
npx playwright test --project=webkit
```

👉 `playwright.config.ts`에 `projects` 설정이 있어야 합니다.

---

3. 결과 확인

---

- **터미널 출력** : 기본적으로 Pass/Fail 결과가 나옵니다.
- **HTML 리포트 열기** :
  ```bash
  npx playwright show-report
  ```
  → 실행 후 브라우저로 상세 리포트를 확인할 수 있습니다.

---

4. 디버깅 실행

---

- 테스트 실행 과정을 눈으로 보고 싶을 때:
  ```bash
  npx playwright test --headed
  ```
- 한 단계씩 확인하고 싶을 때:
  ```bash
  npx playwright test --debug
  ```

---

👉 혹시 원하시면, 제가 **`playwright.config.ts` 기본 템플릿**을 만들어드릴 수 있는데, 그 안에 `baseURL`, `projects`(크롬/엣지/파이어폭스) 설정도 넣어드릴까요?

---

**You:**

# Instructions

- Following Playwright test failed.
- Explain why, be concise, respect Playwright best practices.
- Provide a snippet of code with the fix, if possible.

# Test info

- Name: 인증 및 로그인 테스트 - 성공 시나리오 >> 올바른 아이디/비밀번호로 로그인 시 마이페이지로 이동해야 함
- Location: login.spec.ts:28:7

# Error details

Error: locator.click: Error: strict mode violation: getByRole('button', { name: '로그인' }) resolved to 6 elements: 1) <button type="submit" class="Button_button__S9rjD Button_contained__DJSrI Button_large___Kecx Button_primary__5usVQ">…</button> aka getByRole('button', { name: '로그인', exact: true }) 2) <button type="button" class="Button_button__S9rjD Button_icon__oFUyf Button_large___Kecx">…</button> aka getByRole('button', { name: '네이버 계정으로 로그인' }) 3) <button type="button" class="Button_button__S9rjD Button_icon__oFUyf Button_large___Kecx">…</button> aka getByRole('button', { name: '카카오톡 계정으로 로그인' }) 4) <button type="button" class="Button_button__S9rjD Button_icon__oFUyf Button_large___Kecx">…</button> aka getByRole('button', { name: '페이스북 계정으로 로그인' }) 5) <button type="button" class="Button_button__S9rjD Button_icon__oFUyf Button_large___Kecx">…</button> aka getByRole('button', { name: '구글 계정으로 로그인' }) 6) <button type="button" class="Button_button__S9rjD Button_icon__oFUyf Button_large___Kecx">…</button> aka getByRole('button', { name: '애플 계정으로 로그인' })

Call log:

- waiting for getByRole('button', { name: '로그인' })

35 |
36 | await test.step("로그인 제출", async () => {

> 37 | await page.getByRole("button", { name: "로그인" }).click();

     |                                                       ^

38 | });
39 |
40 | await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
at /Users/bagjin-a/Documents/GitHub/qa-ai-challenge/tests/login.spec.ts:37:55
at /Users/bagjin-a/Documents/GitHub/qa-ai-challenge/tests/login.spec.ts:36:16

# Page snapshot

yaml

- main:
  - button ""
  - text: 알바몬·잡코리아 통합 로그인
  - button "개인회원"
  - button "기업회원"
  - img "세상 모든 커리어는 하나로 통한다! 잡코리아 알바몬"
  - button "PC 키보드 보기 "
  - text: 
  - textbox " clear": user01
  - button "clear"
  - text: 
  - textbox "  clear": Pass123!
  - button ""
  - button "clear"
  - button "로그인"
  - text: 로그인 상태 유지
  - checkbox "로그인 상태 유지 " [checked]
  - text: 
  - list:
    - listitem:
      - button "네이버 계정으로 로그인"
    - listitem:
      - button "카카오톡 계정으로 로그인"
    - listitem:
      - button "페이스북 계정으로 로그인"
    - listitem:
      - button "구글 계정으로 로그인"
    - listitem:
      - button "애플 계정으로 로그인"
  - list:
    - listitem:
      - link "아이디 찾기":
        - /url: /user-account/find/id?memberType=PERSONAL
    - listitem:
      - link "비밀번호 찾기":
        - /url: /user-account/find/password?memberType=PERSONAL
    - listitem:
      - link "회원가입":
        - /url: /user-account/join
      - paragraph:
        - emphasis: 하나로 통하는 No.1 통합회원 가입
        - text: 2025 K-BPI 취업/알바 포털 1위
  - button "N번 탈락에 지쳤다면, 이제 일자리매칭플랫폼!":
    - img "N번 탈락에 지쳤다면, 이제 일자리매칭플랫폼!"
- alert

# Test source

ts
1 | import { test, expect, Page } from "@playwright/test";
2 |
3 | const CREDENTIALS = { id: "user01", pw: "Pass123!", userName: "박진아님" };
4 |
5 | test.describe("인증 및 로그인 테스트 - 성공 시나리오", () => {
6 | test.beforeEach(async ({ page }) => {
7 | await page.goto("/user-account/login");
8 | await expect(page).toHaveURL(/\/user-account\/login$/);
   9 |   });
   10 |
   11 |   async function assertLoggedInToMyPage(page: Page, userName: string) {
   12 |     // URL 검증
   13 |     await expect(page).toHaveURL(/\/personal\/mypage$/);
14 |
15 | // 실명 요소 선택자 (마이페이지 헤더의 이름 영역)
16 | const nameEl = page.locator(
17 | "section.Mypage_mypage-info**eyAvx .mypage-info**user-name > span"
18 | );
19 |
20 | await expect(nameEl).toBeVisible();
21 |
22 | // '이름 + 님' 형태를 정규식으로 검증
23 | // 공백/개행이 끼어도 통과하도록 \s* 허용
24 | const expected = new RegExp(`^\\s*${userName}\\s*님\\s*$`);
25 | await expect(nameEl).toHaveText(expected);
26 | }
27 |
28 | test("올바른 아이디/비밀번호로 로그인 시 마이페이지로 이동해야 함", async ({
29 | page,
30 | }) => {
31 | await test.step("아이디/비밀번호 입력", async () => {
32 | await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
33 | await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
34 | });
35 |
36 | await test.step("로그인 제출", async () => {

> 37 | await page.getByRole("button", { name: "로그인" }).click();

      |                                                       ^ Error: locator.click: Error: strict mode violation: getByRole('button', { name: '로그인' }) resolved to 6 elements:

38 | });
39 |
40 | await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
41 | await assertLoggedInToMyPage(page, CREDENTIALS.userName);
42 | });
43 | });
44 |
45 | test("앞뒤 공백이 포함된 자격증명은 트리밍되어 정상 로그인되어야 함", async ({
46 | page,
47 | }) => {
48 | await test.step("공백 포함 자격증명 입력", async () => {
49 | await page.getByPlaceholder("아이디").fill(`${CREDENTIALS.id}`);
50 | await page.getByPlaceholder("비밀번호").fill(`${CREDENTIALS.pw}`);
51 | });
52 |
53 | await test.step("로그인 제출", async () => {
54 | await page.getByRole("button", { name: "로그인" }).click();
55 | });
56 |
57 | await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
58 | await assertLoggedInToMyPage(page, CREDENTIALS.userName);
59 | });
60 | });
61 |
62 | test("미인증 상태에서 /personal/mypage 접근 시 로그인 후 원래 페이지로 복귀해야 함", async ({
63 | page,
64 | }) => {
65 | await test.step("보호 페이지 직접 접근 → 로그인 페이지로 리다이렉트 확인", async () => {
66 | await page.goto("/personal/mypage");
67 | await expect(page).toHaveURL(/\/user-account\/login$/);
68 | });
69 |
70 | await test.step("자격증명 입력 후 로그인", async () => {
71 | await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
72 | await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
73 | await page.getByRole("button", { name: "로그인" }).click();
74 | });
75 |
76 | await test.step("원래 목표 페이지로 복귀 검증", async () => {
77 | await assertLoggedInToMyPage(page, CREDENTIALS.userName);
78 | });
79 | });
80 |
81 | test("비밀번호 입력창에서 엔터(완료 키)로 제출 시 정상 로그인되어야 함", async ({
82 | page,
83 | }) => {
84 | await test.step("자격증명 입력", async () => {
85 | await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
86 | await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
87 | });
88 |
89 | await test.step("엔터(완료) 키로 제출", async () => {
90 | await page.getByPlaceholder("비밀번호").press("Enter");
91 | });
92 |
93 | await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
94 | await assertLoggedInToMyPage(page, CREDENTIALS.userName);
95 | });
96 | });
97 |
98 | test("브라우저 자동완성으로 채워진 값으로 로그인 시 정상 동작해야 함", async ({
99 | page,
100 | }) => {
101 | await test.step("자동완성 상태 에뮬레이션(값 주입 + 이벤트 디스패치)", async () => {
102 | // 실제 저장 자격증명 팝업을 테스트 환경에서 제어하기 어려워 DOM 이벤트로 에뮬레이션
103 | await page.evaluate(
104 | ({ id, pw }) => {
105 | const idEl =
106 | document.querySelector<HTMLInputElement>("#memberId") ??
107 | document.querySelector<HTMLInputElement>('[placeholder="아이디"]');
108 | const pwEl =
109 | document.querySelector<HTMLInputElement>("#memberPassword") ??
110 | document.querySelector<HTMLInputElement>(
111 | '[placeholder="비밀번호"]'
112 | );
113 | if (!idEl || !pwEl) return;
114 | idEl.value = id;
115 | pwEl.value = pw;
116 | idEl.dispatchEvent(new Event("input", { bubbles: true }));
117 | pwEl.dispatchEvent(new Event("input", { bubbles: true }));
118 | idEl.dispatchEvent(new Event("change", { bubbles: true }));
119 | pwEl.dispatchEvent(new Event("change", { bubbles: true }));
120 | },
121 | { id: CREDENTIALS.id, pw: CREDENTIALS.pw }
122 | );
123 | });
124 |
125 | await test.step("로그인 제출", async () => {
126 | await page.getByRole("button", { name: "로그인" }).click();
127 | });
128 |
129 | await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
130 | await assertLoggedInToMyPage(page, CREDENTIALS.userName);
131 | });
132 | });
133 | });
134 |
135 | //

---

**ChatGPT:**

**왜 실패했나 (요약)**  
`getByRole('button', { name: '로그인' })` 이 **여러 요소**에 매칭됩니다.  
페이지에 _"네이버/카카오/구글/애플 계정으로 로그인"_ 같은 소셜 버튼들이 있어 Playwright의 기본 **부분 일치(name substring)** 규칙에 의해 모두 잡혀 **strict mode 위반**이 발생했습니다.

**베스트 프랙티스에 맞는 수정 방법(택1)**

1. **정확 일치**로 한정

```ts
await page.getByRole("button", { name: /^로그인$/, exact: true }).click();
```

2. **버튼 타입으로 한정**(+ 접근성 유지)

```ts
await page
  .getByRole("button", { name: /^로그인$/ })
  .filter({ has: page.locator('button[type="submit"]') })
  .first()
  .click();
```

3. **의미 있는 속성으로 한정**(접근성 우선이 어렵다면)

```ts
await page.locator('button[type="submit"]:has-text("로그인")').click();
```

---

### 코드 스니펫 (간단 패치: 정확 일치로 통일)

아래처럼 테스트 내 모든 클릭 지점을 교체하세요(37, 54, 73, 126 라인 등).

```ts
// before
await page.getByRole("button", { name: "로그인" }).click();

// after
const loginBtn = page.getByRole("button", { name: /^로그인$/, exact: true });
await expect(loginBtn).toBeVisible(); // 선택 안정성 향상
await loginBtn.click();
```

이렇게 하면 소셜 로그인 버튼(“○○ 계정으로 **로그인**”)은 제외되고, **텍스트가 정확히 “로그인”인 제출 버튼**만 클릭되어 테스트가 통과합니다.

---

**You:**

# Instructions

- Following Playwright test failed.
- Explain why, be concise, respect Playwright best practices.
- Provide a snippet of code with the fix, if possible.

# Test info

login.spec.ts:52 › 아이디, 비밀번호 로그인 성공 플로우 › 앞뒤 공백이 포함된 입력값은 트리밍되어 정상 로그인되어야 함

# Error details

Error: Timed out 5000ms waiting for expect(page).toHaveURL(expected)

Expected pattern: /\/personal\/mypage$/
Received string: "https://m.albamon.com/user-account/login?my_page=1"
Call log:

- Expect "toHaveURL" with timeout 5000ms
  9 × unexpected value "https://m.albamon.com/user-account/login?my_page=1"

# Page snapshot

yaml

- main:
  - button ""
  - text: 알바몬·잡코리아 통합 로그인
  - button "개인회원"
  - button "기업회원"
  - img "세상 모든 커리어는 하나로 통한다! 잡코리아 알바몬"
  - button "PC 키보드 보기 "
  - text: 
  - textbox "": dndbekfrl1
  - text: 
  - textbox ""
  - button "로그인"
  - text: 로그인 상태 유지
  - checkbox "로그인 상태 유지 " [checked]
  - text: 
  - list:
    - listitem:
      - button "네이버 계정으로 로그인"
    - listitem:
      - button "카카오톡 계정으로 로그인"
    - listitem:
      - button "페이스북 계정으로 로그인"
    - listitem:
      - button "구글 계정으로 로그인"
    - listitem:
      - button "애플 계정으로 로그인"
  - list:
    - listitem:
      - link "아이디 찾기":
        - /url: /user-account/find/id?memberType=PERSONAL
    - listitem:
      - link "비밀번호 찾기":
        - /url: /user-account/find/password?memberType=PERSONAL
    - listitem:
      - link "회원가입":
        - /url: /user-account/join
      - paragraph:
        - emphasis: 하나로 통하는 No.1 통합회원 가입
        - text: 2025 K-BPI 취업/알바 포털 1위
  - button "더이상 미룰 수 없다! 당신의 취업!":
    - img "더이상 미룰 수 없다! 당신의 취업!"
- alert: 알바몬·잡코리아 통합 로그인

# Test source

ts
1 | import { test, expect, Page } from "@playwright/test";
2 |
3 | import { CREDENTIALS } from "./fixtures/user";
4 |
5 | test.describe("아이디, 비밀번호 로그인 성공 플로우", () => {
6 | // 항상 로그아웃 상태에서 시작
7 | test.beforeEach(async ({ context, page }) => {
8 | await page.goto("/");
9 | await context.clearCookies();
10 | await context.clearPermissions();
11 | });
12 |
13 | async function assertLoggedInToMyPage(page: Page, userName: string) {
14 | // URL 검증

> 15 | await expect(page).toHaveURL(/\/personal\/mypage$/);

      |                        ^ Error: Timed out 5000ms waiting for expect(page).toHaveURL(expected)

16 |
17 | // 실명 요소 선택자 (마이페이지 헤더의 이름 영역)
18 | const nameEl = page.locator(
19 | "section.Mypage_mypage-info**eyAvx .mypage-info**user-name > span"
20 | );
21 |
22 | await expect(nameEl).toBeVisible();
23 |
24 | // '이름 + 님' 형태를 정규식으로 검증
25 | // 공백/개행이 끼어도 통과하도록 \s* 허용
26 | const expected = new RegExp(`^\\s*${userName}\\s*님\\s*$`);
  27  |     await expect(nameEl).toHaveText(expected);
  28  |   }
  29  | 
  30  |   test("올바른 아이디/비밀번호로 로그인 시 마이페이지로 이동해야 함", async ({
  31  |     page,
  32  |   }) => {
  33  |     await test.step("바텀 내비게이션의 마이페이지 메뉴 클릭해 로그인 페이지로 이동", async () => {
  34  |       await page.getByRole("link", { name: "마이페이지" }).click();
  35  |       await expect(page).toHaveURL(/\/user-account\/login(\?.*)?$/);
  36  |     });
  37  | 
  38  |     await test.step("아이디/비밀번호 입력", async () => {
  39  |       await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
  40  |       await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
  41  |     });
  42  | 
  43  |     await test.step("로그인 제출", async () => {
  44  |       await page.getByRole("button", { name: /^로그인$/, exact: true }).click();
  45  |     });
  46  | 
  47  |     await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
  48  |       await assertLoggedInToMyPage(page, CREDENTIALS.userName);
  49  |     });
  50  |   });
  51  | 
  52  |   test("앞뒤 공백이 포함된 입력값은 트리밍되어 정상 로그인되어야 함", async ({
  53  |     page,
  54  |   }) => {
  55  |     await test.step("바텀 내비게이션의 마이페이지 메뉴 클릭해 로그인 페이지로 이동", async () => {
  56  |       await page.getByRole("link", { name: "마이페이지" }).click();
  57  |       await expect(page).toHaveURL(/\/user-account\/login(\?.*)?$/);
  58  |     });
  59  | 
  60  |     await test.step("공백 포함 아이디, 비밀번호 입력", async () => {
  61  |       await page.getByPlaceholder("아이디").fill(` ${CREDENTIALS.id}  `);
  62  |       await page.getByPlaceholder("비밀번호").fill(`  ${CREDENTIALS.pw}  `);
  63  |     });
  64  | 
  65  |     await test.step("로그인 제출", async () => {
  66  |       await page.getByRole("button", { name: /^로그인$/, exact: true }).click();
67 | });
68 |
69 | await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
70 | await assertLoggedInToMyPage(page, CREDENTIALS.userName);
71 | });
72 | });
73 |
74 | test("미인증 상태에서 /personal/mypage 접근 시 로그인 후 원래 페이지로 복귀해야 함", async ({
75 | page,
76 | }) => {
77 | await test.step("보호 페이지 직접 접근 → 로그인 페이지로 리다이렉트 확인", async () => {
78 | await page.goto("/personal/mypage");
79 | const url = page.url();
80 | console.log(url);
81 | expect(url).toContain("/user-account/login");
82 | });
83 |
84 | await test.step("아이디, 비밀번호 입력 후 로그인", async () => {
85 | await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
86 | await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
87 | await page.getByRole("button", { name: /^로그인$/, exact: true }).click();
  88  |     });
  89  | 
  90  |     await test.step("원래 목표 페이지로 복귀 검증", async () => {
  91  |       await assertLoggedInToMyPage(page, CREDENTIALS.userName);
  92  |     });
  93  |   });
  94  | 
  95  |   test("비밀번호 입력창에서 엔터(완료 키)로 제출 시 정상 로그인되어야 함", async ({
  96  |     page,
  97  |   }) => {
  98  |     await test.step("바텀 내비게이션의 마이페이지 메뉴 클릭해 로그인 페이지로 이동", async () => {
  99  |       await page.getByRole("link", { name: "마이페이지" }).click();
  100 |       await expect(page).toHaveURL(/\/user-account\/login(\?.*)?$/);
101 | });
102 |
103 | await test.step("아이디, 비밀번호 입력", async () => {
104 | await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
105 | await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
106 | });
107 |
108 | await test.step("엔터(완료) 키로 제출", async () => {
109 | await page.getByPlaceholder("비밀번호").press("Enter");
110 | });
111 |
112 | await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
113 | await assertLoggedInToMyPage(page, CREDENTIALS.userName);
114 | });
115 | });

---

**ChatGPT:**

**왜 실패했나 (원인)**

- 기대 URL `/personal/mypage`로 이동하지 않았고, 실제로는 **로그인 페이지에 그대로 남아** `?my_page=1` 쿼리가 붙었습니다.
- 공백이 포함된 자격 정보가 **클라이언트에서 트리밍되지 않거나** 서버가 그대로 비교하여 **인증 실패** → 로그인 화면 유지.
- 즉, 테스트는 “공백 트리밍 후 성공”을 검증하고 있는데 **제품 동작은 트리밍이 없음**(또는 서버가 공백을 허용하지 않음).

**플레이wright 관점 베스트 프랙티스**

- 내비게이션 기대 시 **동시 대기**(click와 wait을 `Promise.all`로 묶기).
- 성공/실패 **양분기 가드**(성공 안 되면 명확한 실패 원인을 로그로 표시).
- 제품 요구사항이 “공백 트리밍”이라면, **앱 코드에서 트리밍**하고 테스트는 그 사실을 검증.

---

## 선택지 A) 제품 수정(권장) — 입력 트리밍 추가

프런트(예시)

```ts
// 로그인 제출 직전
const id = idInput.value.trim();
const pw = pwInput.value.trim();
login({ id, pw });
```

백엔드(선택)

```ts
const id = req.body.id?.trim();
const pw = req.body.pw?.trim();
```

테스트는 그대로 두되 클릭과 내비게이션을 동시 대기하도록 안정화:

```ts
await test.step("로그인 제출", async () => {
  await Promise.all([
    page.waitForURL(/\/personal\/mypage$/),
    page.getByRole("button", { name: /^로그인$/, exact: true }).click(),
  ]);
});
```

---

## 선택지 B) 테스트 가드 추가 — 성공/실패를 명확히 보고

제품이 아직 트리밍을 지원하지 않는다면, 테스트를 “요구사항 불일치”로 **명시적 실패**시키고 원인을 로깅:

```ts
await test.step("로그인 제출", async () => {
  await page.getByRole("button", { name: /^로그인$/, exact: true }).click();
});

await test.step("성공 또는 실패 분기", async () => {
  const success = page
    .waitForURL(/\/personal\/mypage$/, { timeout: 4000 })
    .then(() => true)
    .catch(() => false);

  if (await success) {
    await assertLoggedInToMyPage(page, CREDENTIALS.userName);
  } else {
    // 실패 증거 수집 후 명확히 실패 처리
    const current = page.url();
    const errText = await page
      .locator("text=아이디 또는 비밀번호")
      .first()
      .textContent()
      .catch(() => "");
    test.fail(true, "공백 트리밍 미동작으로 요구사항 불일치");
    throw new Error(
      `Expected trimmed login → /personal/mypage, but stayed on ${current}. Hint: ${errText}`
    );
  }
});
```

---

### 한 줄 정리

- **원인**: 공백이 트리밍되지 않아 서버 인증 실패 → 로그인 페이지 유지.
- **해결**: 제품에 **트리밍 로직 추가**(권장) + 테스트에서 **동시 대기 패턴** 적용,  
   또는 제품 반영 전에는 **분기 가드로 원인 명확화**해 실패를 의미 있게 만들기.

---

**You:**

# Instructions

- Following Playwright test failed.
- Explain why, be concise, respect Playwright best practices.
- Provide a snippet of code with the fix, if possible.

# Test info

login.spec.ts:185 › 인증 및 로그인 테스트 - 실패 시나리오 › 아이디 공란 → alert 노출, 아이디 포커스 & 요청 미발생(페이지 유지)

# Error details

```

Error: locator.click: Test timeout of 30000ms exceeded.
Call log:

- waiting for getByRole('button', { name: /^로그인$/ })
  - locator resolved to <button type="submit" class="Button_button__S9rjD Button_contained__DJSrI Button_large___Kecx Button_primary__5usVQ">…</button>
- attempting click action
  - waiting for element to be visible, enabled and stable
  - element is visible, enabled and stable
  - scrolling into view if needed
  - done scrolling
  - performing click action

```

# Test source

```ts
  97  |   });
  98  |
  99  |   test("비밀번호 입력창에서 엔터(완료 키)로 제출 시 정상 로그인되어야 함", async ({
  100 |     page,
  101 |   }) => {
  102 |     await test.step("바텀 내비게이션의 마이페이지 메뉴 클릭해 로그인 페이지로 이동", async () => {
  103 |       await page.getByRole("link", { name: "마이페이지" }).click();
  104 |       await expect(page).toHaveURL(/\/user-account\/login(\?.*)?$/);
  105 |     });
  106 |
  107 |     await test.step("아이디, 비밀번호 입력", async () => {
  108 |       await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
  109 |       await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
  110 |     });
  111 |
  112 |     await test.step("엔터(완료) 키로 제출", async () => {
  113 |       await page.getByPlaceholder("비밀번호").press("Enter");
  114 |     });
  115 |
  116 |     await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
  117 |       await assertLoggedInToMyPage(page, CREDENTIALS.userName);
  118 |     });
  119 |   });
  120 | });
  121 |
  122 | const loginBtn = (page: Page) =>
  123 |   page.getByRole("button", { name: /^로그인$/, exact: true });
  124 |
  125 | test.describe("인증 및 로그인 테스트 - 실패 시나리오", () => {
  126 |   test.beforeEach(async ({ page, context }) => {
  127 |     await page.goto("/");
  128 |     await page.getByRole("link", { name: "마이페이지" }).click();
  129 |     await expect(page).toHaveURL(/\/user-account\/login(\?.*)?$/);
  130 |
  131 |     await context.clearCookies();
  132 |     await context.clearPermissions();
  133 |   });
  134 |
  135 |   test("존재하지 않는 계정 → alert 노출 & 로그인 페이지 유지", async ({
  136 |     page,
  137 |   }) => {
  138 |     await test.step("입력", async () => {
  139 |       await page.getByPlaceholder("아이디").fill("no_user");
  140 |       await page.getByPlaceholder("비밀번호").fill("Any123!");
  141 |     });
  142 |
  143 |     await test.step("로그인 시도 → alert 확인", async () => {
  144 |       const [dlg] = await Promise.all([
  145 |         page.waitForEvent("dialog"),
  146 |         loginBtn(page).click(),
  147 |       ]);
  148 |       await expect(dlg.message()).toContain(
  149 |         "아이디 또는 비밀번호가 일치하지 않습니다. 입력 내용을 다시 확인해 주세요."
  150 |       );
  151 |       await dlg.accept();
  152 |     });
  153 |
  154 |     await test.step("페이지/포커스 유지 확인", async () => {
  155 |       await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
  156 |       await expect(page.getByPlaceholder("아이디")).toBeFocused();
  157 |     });
  158 |   });
  159 |
  160 |   test("비밀번호 불일치 → alert 노출, 비밀번호만 초기화 & 버튼 재활성화", async ({
  161 |     page,
  162 |   }) => {
  163 |     await test.step("입력", async () => {
  164 |       await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
  165 |       await page.getByPlaceholder("비밀번호").fill("Wrong999");
  166 |     });
  167 |
  168 |     await test.step("로그인 시도 → alert 확인", async () => {
  169 |       const [dlg] = await Promise.all([
  170 |         page.waitForEvent("dialog"),
  171 |         loginBtn(page).click(),
  172 |       ]);
  173 |       await expect(dlg.message()).toContain(
  174 |         "아이디 또는 비밀번호가 일치하지 않습니다. 입력 내용을 다시 확인해 주세요."
  175 |       );
  176 |       await dlg.accept();
  177 |     });
  178 |
  179 |     await test.step("필드/버튼 상태 확인", async () => {
  180 |       await expect(page.getByPlaceholder("비밀번호")).toHaveValue("");
  181 |       await expect(loginBtn(page)).toBeEnabled();
  182 |     });
  183 |   });
  184 |
  185 |   test("아이디 공란 → alert 노출, 아이디 포커스 & 요청 미발생(페이지 유지)", async ({
  186 |     page,
  187 |   }) => {
  188 |     await test.step("비밀번호만 입력", async () => {
  189 |       await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
  190 |       await expect(page.getByPlaceholder("아이디")).toHaveValue(""); // 공란 보장
  191 |       await expect(loginBtn(page)).toBeEnabled();
  192 |     });
  193 |
  194 |     await test.step("로그인 시도 → alert 확인", async () => {
  195 |       const [dlg] = await Promise.all([
  196 |         page.waitForEvent("dialog", { timeout: 5000 }),
> 197 |         loginBtn(page).click(),
      |                        ^ Error: locator.click: Test timeout of 30000ms exceeded.
  198 |       ]);
  199 |       await expect(dlg.message()).toContain("아이디를 입력해 주세요"); // 실제 메시지 그대로
  200 |       await dlg.accept();
  201 |     });
  202 |
  203 |     await test.step("페이지/포커스 유지", async () => {
  204 |       await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
  205 |       await expect(page.getByPlaceholder("아이디")).toBeFocused();
  206 |     });
  207 |   });
  208 |
  209 |   test("비밀번호 공란 → 경고 노출/제출 차단, 비밀번호 포커스 & 페이지 유지", async ({
  210 |     page,
  211 |   }) => {
  212 |     // Given
  213 |     await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
  214 |
  215 |     // When: alert가 있을 수도/없을 수도 있으니 조건부로 대기
  216 |     const dialogPromise = page
  217 |       .waitForEvent("dialog", { timeout: 1200 })
  218 |       .catch(() => null);
  219 |     await loginBtn(page).click(); // submit 시도
  220 |
  221 |     const dlg = await dialogPromise;
  222 |
  223 |     if (dlg) {
  224 |       // 일부 구현에서 네이티브 alert 사용
  225 |       await expect(dlg.message()).toMatch(
  226 |         /비밀번호.*입력해 주세요|입력해주세요/
  227 |       );
  228 |       await dlg.accept();
  229 |     } else {
  230 |       // 일반적인 구현: 제출 차단 + 인라인 피드백
  231 |       // 1) 페이지 유지
  232 |       await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
  233 |       // 2) 비밀번호 포커스
  234 |       await expect(page.getByPlaceholder("비밀번호")).toBeFocused();
  235 |       // 3) 제출 차단 신호 (택1)
  236 |       await expect(loginBtn(page)).toBeDisabled(); // 비활성화 버튼인 경우
  237 |       // 또는 인라인/토스트 메시지
  238 |       // await expect(page.getByText(/비밀번호.*입력해 주세요|입력해주세요/i).first()).toBeVisible();
  239 |     }
  240 |   });
  241 |
  242 |   test("아이디 형식 위반 → 제출 차단: alert 또는 보조텍스트 노출", async ({
  243 |     page,
  244 |   }) => {
  245 |     await test.step("정책 위반 값 입력", async () => {
  246 |       // 예: 정책이 영숫자 4~16자 → 'ab'는 위반
  247 |       await page.getByPlaceholder("아이디").fill("ab");
  248 |       await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
  249 |     });
  250 |
  251 |     await test.step("로그인 시도 → 클라 검증 확인", async () => {
  252 |       const dialogPromise = page
  253 |         .waitForEvent("dialog", { timeout: 1200 })
  254 |         .catch(() => null);
  255 |       await loginBtn(page).click();
  256 |
  257 |       const dlg = await dialogPromise;
  258 |       if (dlg) {
  259 |         await expect(dlg.message()).toMatch(/아이디 형식을 확인/i);
  260 |         await dlg.accept();
  261 |       } else {
  262 |         // 서비스 실제 에러 힌트 선택자로 교체 권장
  263 |         await expect(
  264 |           page.getByText(/아이디 형식을 확인|형식을 확인/i).first()
  265 |         ).toBeVisible();
  266 |       }
  267 |     });
  268 |
  269 |     await test.step("내비게이션 차단 확인", async () => {
  270 |       await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
  271 |     });
  272 |   });
  273 | });
  274 |


```

---

**ChatGPT:**

왜 실패했나 (간단히)
아이디 공란 케이스에서 로그인 버튼 클릭과 waitForEvent('dialog')를 Promise.all로 묶은 패턴이 교착(deadlock)을 만들었습니다.
네이티브 alert는 클릭 직후 뜨고, click()은 dialog가 처리(accept/dismiss)될 때까지 resolve되지 않습니다. 그런데 Promise.all([ waitForEvent('dialog'), click() ])는 두 약속 모두 끝나야 풀려서, alert를 처리하기 전까지 click()이 완료되지 않아 클릭 대기 30s 타임아웃이 발생했습니다.

베스트 프랙티스
• dialog는 클릭과 동시에 대기하되, dialog가 뜨면 즉시 accept 하고, 클릭은 자동으로 풀리게 하세요.
• 즉, dialog.then(d => d.accept())를 별도 Promise로 띄우고, click()만 await 합니다.
• 전역 page.on('dialog', …)와 섞어 쓰지 마세요(이중 처리 오류 유발).

✅ 수정 스니펫 (문제 라인 교체: 195–201)

```
await test.step('로그인 시도 → alert 확인', async () => {
// dialog를 병렬로 대기하고, 뜨는 즉시 accept
const whenDialog = page.waitForEvent('dialog', { timeout: 5000 })
.then(async d => {
await expect(d.message()).toContain('아이디를 입력해 주세요'); // 실제 문구
await d.accept();
});

await loginBtn(page).click(); // click은 dialog가 처리되면 자동으로 resolve

await whenDialog; // dialog 검증/처리가 실제로 수행됐는지 보장
});
```

추가 팁
• 혹시 beforeEach에서 page.on('dialog', …) 전역 핸들러를 붙였다면 제거하세요(중복 처리 → “already handled” 에러).
• (/user-account/login) URL 검증은 /(?:\?.\*)?$/ 형태로 쿼리 허용이 안정적입니다.
