# 테스트 코드 작성 과정

> 일부 테스트 코드 작성 과정입니다. 프롬프트 단계에서 “Playwright 코드 가이드를 따르라" 지시를 하여, 전체 테스트가 일관된 스타일과 규칙을 유지하도록 했습니다.

**You:**

5가지 테스트 케이스에 대해서 playwright 테스트를 작성해줘

---

**ChatGPT:**

아래 코드는 요청하신 **5가지 성공 시나리오**를 Playwright로 구현한 예시야.  
이전에 공유한 **테스트 작성 가이드**를 따르며, 테스트 설명을 구체적으로 쓰고 `test.step`으로 단계를 나눴어.  
(셀렉터는 예시: `#idInput`, `#pwInput`, `#loginBtn`, `#userName`, 경로는 `/login` → `/personal/mypage`. 프로젝트에 맞게 치환해줘!)

```ts
// tests/login.success.spec.ts
import { test, expect } from "@playwright/test";

const USER = { id: "user01", pw: "Pass123!" };

test.describe("인증 및 로그인 테스트 - 성공 시나리오", () => {
  test.beforeEach(async ({ page }) => {
    // baseURL이 playwright.config.ts에 설정돼 있다고 가정합니다.
    await page.goto("/login");
    await expect(page).toHaveURL(/\/login$/);
  });

  test("① 올바른 아이디/비밀번호로 로그인 시 마이페이지로 이동해야 함", async ({
    page,
  }) => {
    await test.step("아이디/비밀번호 입력", async () => {
      await page.fill("#idInput", USER.id);
      await page.fill("#pwInput", USER.pw);
    });

    await test.step("로그인 버튼 탭", async () => {
      await page.click("#loginBtn");
    });

    await test.step("마이페이지로 이동 및 사용자명 표시 검증", async () => {
      await expect(page).toHaveURL(/\/personal\/mypage$/);
      const name = page.locator("#userName");
      await expect(name).toBeVisible();
      await expect(name).toHaveText(USER.id);
    });
  });

  test("② 앞뒤 공백이 포함된 자격증명은 트리밍되어 정상 로그인되어야 함", async ({
    page,
  }) => {
    await test.step("공백 포함 자격증명 입력", async () => {
      await page.fill("#idInput", `  ${USER.id}  `);
      await page.fill("#pwInput", `  ${USER.pw}  `);
    });

    await test.step("로그인 제출", async () => {
      await page.click("#loginBtn");
    });

    await test.step("마이페이지 이동 및 사용자명 확인", async () => {
      await expect(page).toHaveURL(/\/personal\/mypage$/);
      await expect(page.locator("#userName")).toHaveText(USER.id);
    });
  });

  test("③ 미인증 상태에서 /personal/mypage 접근 시 로그인 후 원래 페이지로 복귀해야 함", async ({
    page,
  }) => {
    await test.step("보호 페이지 직접 접근 → 로그인 페이지로 리다이렉트 확인", async () => {
      await page.goto("/personal/mypage"); // 미인증 접근
      await expect(page).toHaveURL(/\/login$/);
    });

    await test.step("자격증명 입력 후 로그인", async () => {
      await page.fill("#idInput", USER.id);
      await page.fill("#pwInput", USER.pw);
      await page.click("#loginBtn");
    });

    await test.step("원래 목표 페이지로 복귀 검증", async () => {
      await expect(page).toHaveURL(/\/personal\/mypage$/);
      await expect(page.locator("#userName")).toHaveText(USER.id);
    });
  });

  test("④ 비밀번호 입력창에서 엔터(완료 키)로 제출 시 정상 로그인되어야 함", async ({
    page,
  }) => {
    await test.step("자격증명 입력", async () => {
      await page.fill("#idInput", USER.id);
      await page.fill("#pwInput", USER.pw);
    });

    await test.step("엔터 키로 제출", async () => {
      await page.focus("#pwInput");
      await page.keyboard.press("Enter");
    });

    await test.step("마이페이지 이동 및 사용자명 확인", async () => {
      await expect(page).toHaveURL(/\/personal\/mypage$/);
      await expect(page.locator("#userName")).toHaveText(USER.id);
    });
  });

  test("⑤ 브라우저 자동완성(저장 자격증명)으로 채워진 값으로 로그인 시 정상 동작해야 함", async ({
    page,
  }) => {
    await test.step("자동완성 시나리오 에뮬레이션(값 주입 + 입력 이벤트 디스패치)", async () => {
      // 실제 저장 자격증명을 사용할 수 없을 때, 자동완성으로 채워진 상태를 에뮬레이션
      await page.evaluate(
        ({ id, pw }) => {
          const idEl = document.querySelector<HTMLInputElement>("#idInput");
          const pwEl = document.querySelector<HTMLInputElement>("#pwInput");
          if (!idEl || !pwEl) return;

          idEl.value = id;
          pwEl.value = pw;

          idEl.dispatchEvent(new Event("input", { bubbles: true }));
          pwEl.dispatchEvent(new Event("input", { bubbles: true }));
          idEl.dispatchEvent(new Event("change", { bubbles: true }));
          pwEl.dispatchEvent(new Event("change", { bubbles: true }));
        },
        { id: USER.id, pw: USER.pw }
      );
    });

    await test.step("로그인 버튼 탭", async () => {
      await page.click("#loginBtn");
    });

    await test.step("마이페이지 이동 및 사용자명 확인", async () => {
      await expect(page).toHaveURL(/\/personal\/mypage$/);
      await expect(page.locator("#userName")).toHaveText(USER.id);
    });
  });
});
```

### 메모

- **Locator 우선순위 규칙**을 지키려면 실제 화면에서 접근성 속성/Role이 제공되는지 확인해 `getByRole`, `getByLabel` 등을 우선 쓰는 게 좋아. 지금은 제공 여부를 알 수 없어 ID 기반으로 작성했어.
- 자동완성 케이스는 CI/테스트 환경에서 **저장 자격 증명 팝업을 띄우기 어렵기 때문에**, DOM 값 주입 + 이벤트 디스패치로 “자동완성된 상태”를 **에뮬레이션**했어(실무에서도 흔히 쓰는 방식).
- `baseURL`이 설정되어 있지 않다면 `page.goto('https://…/login')`처럼 절대경로로 바꿔줘.

---

**You:**

로그인 폼 일부 html 구조를 참고해서 선택자를 수정해줘

<div class="Login_input-wrap__Ztpgl"><label class="Textfield_container__B4PgR" data-filled="false" for="memberId"><div class="Textfield_wrap-input__bWG1_"><div class="Textfield_wrap-icon__XBZMW Textfield_left__Ehsve"><i style="font-size:24px" class="Icon_icon__BlZpj icon-system_my"></i></div><input type="text" placeholder="아이디" maxlength="16" name="memberId" id="memberId"><input type="hidden" class="Textfield_hidden-input__cHbQ0"></div></label><label class="Textfield_container__B4PgR" data-filled="false" for="memberPassword"><div class="Textfield_wrap-input__bWG1_"><div class="Textfield_wrap-icon__XBZMW Textfield_left__Ehsve"><i style="font-size:24px" class="Icon_icon__BlZpj icon-system_lock_closed2"></i></div><input type="password" placeholder="비밀번호" maxlength="16" name="memberPassword" id="memberPassword"><input type="hidden" class="Textfield_hidden-input__cHbQ0"></div></label><button type="submit" class="Button_button__S9rjD Button_contained__DJSrI Button_large___Kecx Button_primary__5usVQ"><span class="button-inner">로그인</span></button><div class="logged"><label class="Checkbox_container__E5uOM large" data-label-placement="right" data-group-item="false"><span class="Typography_typography__53V55 Typography_typography--B2__60_O6 Typography_typography--regular__qCojp">로그인 상태 유지</span><input type="checkbox" value="logged" checked=""><span class="Checkbox_checkmark-box__ds0zp"><i class="Icon_icon__BlZpj icon-line_check"></i></span></label></div></div>

---

**ChatGPT:**

좋습니다 👍  
공유해주신 HTML 구조를 기준으로 기존 `data-testid` 대신 **실제 존재하는 속성(id, placeholder, text)** 을 이용해서 Playwright 선택자를 바꿔드릴게요.

---

## 선택자 매핑

- **아이디 입력 필드**
  ```ts
  page.getByPlaceholder("아이디");
  // 또는
  page.locator("#memberId");
  ```
- **비밀번호 입력 필드**
  ```ts
  page.getByPlaceholder("비밀번호");
  // 또는
  page.locator("#memberPassword");
  ```
- **로그인 버튼**
  ```ts
  page.getByRole("button", { name: "로그인" });
  // 또는 (정확히 일치하는 경우)
  page.locator('button:has-text("로그인")');
  ```

---

## 수정된 테스트 코드 예시 (5개 성공 케이스)

```ts
import { test, expect } from "@playwright/test";

test.describe("로그인 성공 시나리오", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("https://m.albamon.com/user-account/login");
  });

  test("올바른 아이디/비밀번호 입력 후 로그인", async ({ page }) => {
    await page.locator("#memberId").fill("user01");
    await page.locator("#memberPassword").fill("Pass123!");
    await page.getByRole("button", { name: "로그인" }).click();

    await expect(page).toHaveURL(/.*\/personal\/mypage/);
    await expect(page.getByTestId("userName")).toHaveText("user01");
  });

  test("앞뒤 공백 자동 트림 후 로그인", async ({ page }) => {
    await page.locator("#memberId").fill("  user01  ");
    await page.locator("#memberPassword").fill("  Pass123!  ");
    await page.getByRole("button", { name: "로그인" }).click();

    await expect(page).toHaveURL(/.*\/personal\/mypage/);
    await expect(page.getByTestId("userName")).toHaveText("user01");
  });

  test("미인증 상태에서 /mypage 직접 접근 시 로그인 후 복귀", async ({
    page,
  }) => {
    await page.goto("https://m.albamon.com/personal/mypage");
    await page.locator("#memberId").fill("user01");
    await page.locator("#memberPassword").fill("Pass123!");
    await page.getByRole("button", { name: "로그인" }).click();

    await expect(page).toHaveURL(/.*\/personal\/mypage/);
    await expect(page.getByTestId("userName")).toHaveText("user01");
  });

  test("엔터(완료 키) 제출", async ({ page }) => {
    await page.locator("#memberId").fill("user01");
    await page.locator("#memberPassword").fill("Pass123!");
    await page.locator("#memberPassword").press("Enter");

    await expect(page).toHaveURL(/.*\/personal\/mypage/);
    await expect(page.getByTestId("userName")).toHaveText("user01");
  });

  test("브라우저 자동완성(저장 자격증명) 후 로그인", async ({ page }) => {
    // 자동완성 흉내: 직접 입력 대신 evaluate 로 value 세팅
    await page.evaluate(() => {
      (document.querySelector("#memberId") as HTMLInputElement).value =
        "user01";
      (document.querySelector("#memberPassword") as HTMLInputElement).value =
        "Pass123!";
    });
    await page.getByRole("button", { name: "로그인" }).click();

    await expect(page).toHaveURL(/.*\/personal\/mypage/);
    await expect(page.getByTestId("userName")).toHaveText("user01");
  });
});
```

---

👉 이렇게 바꿔주면 실제 제공된 HTML 구조와 맞아서 안정적으로 동작할 거예요.  
원한다면 `getByPlaceholder` 버전만 통일해서 쓰는 것도 가능해요.

원해? 아니면 `id` 기반으로 통일해줄까?

---

**You:**

가이드를 참고해서 테스트코드 다시 작성해줘

# Playwright 테스트 작성 가이드

당신은 QA 전문가로 playwright로 테스트 코드를 작성합니다.
다음 가이드를 참고해서 테스트 코드를 작성해주세요.

## 테스트 파일 작성 규칙

### 기본 테스트 구조

ts
import { test, expect } from '@playwright/test';
import { TEST_USERS } from '../fixtures/users';

test.describe('인증 및 로그인 테스트', () => {
test.beforeEach(async ({ page }) => {
await page.goto('/login');
});

test('유효한 자격증명으로 로그인 시 대시보드로 이동', async ({ page }) => {
// 테스트 로직
});
});

## 테스트 케이스 작성 규칙

### 테스트 설명

ts
// ❌ 잘못된 예
test('login test', async ({ page }) => {});

// ✅ 좋은 예
test('유효한 이메일과 비밀번호로 로그인 시 대시보드로 이동해야 함', async ({ page }) => {});

### 테스트 단계 구분

ts
test('상품 구매 프로세스', async ({ page }) => {
await test.step('상품 페이지 진입', async () => {
await page.goto('/products/1');
await expect(page).toHaveURL('/products/1');
});

await test.step('장바구니에 추가', async () => {
await page.getByRole('button', { name: '장바구니 추가' }).click();
await expect(page.getByRole('alert')).toHaveText('장바구니에 추가되었습니다');
});
});

## Locator 전략

### 우선순위

ts
// 1. Role과 접근성 속성 (최우선)
page.getByRole('button', { name: '로그인' })
page.getByLabel('이메일')
page.getByRole('textbox', { name: '비밀번호' })
page.getByRole('heading', { name: '회원가입' })

// 2. 텍스트 및 기타
page.getByText('계정 만들기')
page.getByPlaceholder('이메일을 입력하세요')

// 3. 테스트 ID (Role과 접근성 속성으로 선택이 어려운 경우에 사용)
// ⚠️ 사용 전 반드시 해당 요소에 data-testid 속성이 정의되어 있는지 확인
page.getByTestId('submit-button')

// 안티 패턴
// ❌ 피해야 할 방식
page.locator('.login-btn')
page.locator('div > button')

## 검증(Assertions) 가이드

ts
// 요소 상태 검증
await expect(page.getByRole('button')).toBeEnabled();
await expect(page.getByRole('alert')).toBeVisible();

// 텍스트 검증
await expect(page.getByRole('heading')).toHaveText('환영합니다');

// URL 검증
await expect(page).toHaveURL(/.\*dashboard/);

// 다중 요소 검증
await expect(page.getByRole('listitem')).toHaveCount(3);

## 테스트 데이터 관리

ts
// tests/fixtures/users.ts
export const TEST_USERS = {
valid: {
email: 'test@example.com',
password: 'password123'
},
invalid: {
email: 'invalid@example.com',
password: 'wrong'
}
};

## 모킹 전략

다음과 같은 경우에만 API 모킹을 사용합니다:

- 외부 API 의존성이 있는 경우
- 테스트 환경에서 실제 API가 사용 불가능한 경우
- 특정 에러 상황 테스트가 필요한 경우

ts
// 특정 에러 상황 테스트를 위한 모킹 예시
test('API 에러 발생 시 에러 메시지 표시', async ({ page }) => {
await page.route('\*\*/api/users', route => {
route.fulfill({
status: 500,
contentType: 'application/json',
body: JSON.stringify({ error: '서버 오류가 발생했습니다.' })
});
});

await page.goto('/users');
await expect(page.getByRole('alert')).toHaveText('서버 오류가 발생했습니다.');
});

## 인증 상태 관리 (storageState)

### 인증이 필요한 테스트에서 사용

typescript
// tests/e2e/protected-route.spec.ts
import { test } from '@playwright/test';

test.use({ storageState: './tests/fixtures/auth.json' });

test('인증이 필요한 페이지 접근', async ({ page }) => {
await page.goto('/dashboard');
// ... 테스트 로직
});

---

**ChatGPT:**

```ts
// tests/login.success.spec.ts
import { test, expect } from "@playwright/test";

const CREDENTIALS = { id: "user01", pw: "Pass123!" };
// NOTE: playwright.config.ts 에 baseURL 이 설정되어 있다고 가정합니다.
// (예: baseURL: 'https://m.albamon.com')

test.describe("인증 및 로그인 테스트 - 성공 시나리오", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("/user-account/login");
    await expect(page).toHaveURL(/\/user-account\/login$/);
  });

  async function assertLoggedInToMyPage(page: import("@playwright/test").Page) {
    await expect(page).toHaveURL(/\/personal\/mypage$/);
    // ↓ 서비스의 실제 사용자명 요소 선택자로 교체하세요 (예: #userName, [data-testid="username"])
    await expect(page.getByTestId("username")).toBeVisible();
    await expect(page.getByTestId("username")).toHaveText(CREDENTIALS.id);
  }

  test("올바른 아이디/비밀번호로 로그인 시 마이페이지로 이동해야 함", async ({
    page,
  }) => {
    await test.step("아이디/비밀번호 입력", async () => {
      await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
      await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
    });

    await test.step("로그인 제출", async () => {
      await page.getByRole("button", { name: "로그인" }).click();
    });

    await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
      await assertLoggedInToMyPage(page);
    });
  });

  test("앞뒤 공백이 포함된 자격증명은 트리밍되어 정상 로그인되어야 함", async ({
    page,
  }) => {
    await test.step("공백 포함 자격증명 입력", async () => {
      await page.getByPlaceholder("아이디").fill(`  ${CREDENTIALS.id}  `);
      await page.getByPlaceholder("비밀번호").fill(`  ${CREDENTIALS.pw}  `);
    });

    await test.step("로그인 제출", async () => {
      await page.getByRole("button", { name: "로그인" }).click();
    });

    await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
      await assertLoggedInToMyPage(page);
    });
  });

  test("미인증 상태에서 /personal/mypage 접근 시 로그인 후 원래 페이지로 복귀해야 함", async ({
    page,
  }) => {
    await test.step("보호 페이지 직접 접근 → 로그인 페이지로 리다이렉트 확인", async () => {
      await page.goto("/personal/mypage");
      await expect(page).toHaveURL(/\/user-account\/login$/);
    });

    await test.step("자격증명 입력 후 로그인", async () => {
      await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
      await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
      await page.getByRole("button", { name: "로그인" }).click();
    });

    await test.step("원래 목표 페이지로 복귀 검증", async () => {
      await assertLoggedInToMyPage(page);
    });
  });

  test("비밀번호 입력창에서 엔터(완료 키)로 제출 시 정상 로그인되어야 함", async ({
    page,
  }) => {
    await test.step("자격증명 입력", async () => {
      await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
      await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
    });

    await test.step("엔터(완료) 키로 제출", async () => {
      await page.getByPlaceholder("비밀번호").press("Enter");
    });

    await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
      await assertLoggedInToMyPage(page);
    });
  });

  test("브라우저 자동완성으로 채워진 값으로 로그인 시 정상 동작해야 함", async ({
    page,
  }) => {
    await test.step("자동완성 상태 에뮬레이션(값 주입 + 이벤트 디스패치)", async () => {
      // 실제 저장 자격증명 팝업을 테스트 환경에서 제어하기 어려워 DOM 이벤트로 에뮬레이션
      await page.evaluate(
        ({ id, pw }) => {
          const idEl =
            document.querySelector<HTMLInputElement>("#memberId") ??
            document.querySelector<HTMLInputElement>('[placeholder="아이디"]');
          const pwEl =
            document.querySelector<HTMLInputElement>("#memberPassword") ??
            document.querySelector<HTMLInputElement>(
              '[placeholder="비밀번호"]'
            );
          if (!idEl || !pwEl) return;
          idEl.value = id;
          pwEl.value = pw;
          idEl.dispatchEvent(new Event("input", { bubbles: true }));
          pwEl.dispatchEvent(new Event("input", { bubbles: true }));
          idEl.dispatchEvent(new Event("change", { bubbles: true }));
          pwEl.dispatchEvent(new Event("change", { bubbles: true }));
        },
        { id: CREDENTIALS.id, pw: CREDENTIALS.pw }
      );
    });

    await test.step("로그인 제출", async () => {
      await page.getByRole("button", { name: "로그인" }).click();
    });

    await test.step("마이페이지 이동 및 사용자명 표시 검증", async () => {
      await assertLoggedInToMyPage(page);
    });
  });
});
```

**가이드 반영 포인트**

- 테스트 설명을 구체적으로 작성.
- `test.step`으로 단계 구분.
- Locator는 **Role/Placeholder** 우선 사용(버튼은 `getByRole('button', { name: '로그인' })`, 입력은 `getByPlaceholder('아이디'|'비밀번호')`).
- 검증은 URL, 요소 가시성, 텍스트까지 포함.
- 자동완성 케이스는 테스트 환경 제약을 고려해 **에뮬레이션** 방식 사용.

---

**You:**

로그인 폼 html 구조를 참고해서 선택자를 수정해줘

<div class="Login_input-wrap__Ztpgl"><label class="Textfield_container__B4PgR" data-filled="false" for="memberId"><div class="Textfield_wrap-input__bWG1_"><div class="Textfield_wrap-icon__XBZMW Textfield_left__Ehsve"><i style="font-size:24px" class="Icon_icon__BlZpj icon-system_my"></i></div><input type="text" placeholder="아이디" maxlength="16" name="memberId" id="memberId"><input type="hidden" class="Textfield_hidden-input__cHbQ0"></div></label><label class="Textfield_container__B4PgR" data-filled="false" for="memberPassword"><div class="Textfield_wrap-input__bWG1_"><div class="Textfield_wrap-icon__XBZMW Textfield_left__Ehsve"><i style="font-size:24px" class="Icon_icon__BlZpj icon-system_lock_closed2"></i></div><input type="password" placeholder="비밀번호" maxlength="16" name="memberPassword" id="memberPassword"><input type="hidden" class="Textfield_hidden-input__cHbQ0"></div></label><button type="submit" class="Button_button__S9rjD Button_contained__DJSrI Button_large___Kecx Button_primary__5usVQ"><span class="button-inner">로그인</span></button><div class="logged"><label class="Checkbox_container__E5uOM large" data-label-placement="right" data-group-item="false"><span class="Typography_typography__53V55 Typography_typography--B2__60_O6 Typography_typography--regular__qCojp">로그인 상태 유지</span><input type="checkbox" value="logged" checked=""><span class="Checkbox_checkmark-box__ds0zp"><i class="Icon_icon__BlZpj icon-line_check"></i></span></label></div></div>

---

**ChatGPT:**

알겠습니다 👍  
공유해주신 로그인 폼 HTML 구조를 기준으로, Playwright 선택자를 **가이드의 Locator 전략(접근성 속성 > placeholder > id 순)** 에 맞게 다시 정리해드릴게요.

---

## 🎯 선택자 매핑

### 1. 아이디 입력 필드

```ts
// placeholder 우선
await page.getByPlaceholder("아이디").fill("user01");

// 또는 id 기반
await page.locator("#memberId").fill("user01");
```

### 2. 비밀번호 입력 필드

```ts
await page.getByPlaceholder("비밀번호").fill("Pass123!");
// 또는
await page.locator("#memberPassword").fill("Pass123!");
```

### 3. 로그인 버튼

```ts
// Role + name 기반 (가장 추천)
await page.getByRole("button", { name: "로그인" }).click();

// 대체 방법 (텍스트 포함 버튼)
await page.locator('button:has-text("로그인")').click();
```

### 4. 로그인 상태 유지 체크박스

```ts
// label 기반 접근 (권장)
await page.getByLabel("로그인 상태 유지").check();

// 대체 방법
await page.locator('input[type="checkbox"][value="logged"]').check();
```

---

## 📌 수정 후 Playwright 예시 (성공 케이스)

```ts
import { test, expect } from "@playwright/test";

test.describe("로그인 성공 시나리오", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("/user-account/login");
  });

  test("올바른 아이디/비밀번호 입력 시 마이페이지로 이동해야 함", async ({
    page,
  }) => {
    await test.step("아이디/비밀번호 입력", async () => {
      await page.getByPlaceholder("아이디").fill("user01");
      await page.getByPlaceholder("비밀번호").fill("Pass123!");
    });

    await test.step("로그인 버튼 클릭", async () => {
      await page.getByRole("button", { name: "로그인" }).click();
    });

    await test.step("마이페이지로 이동 및 사용자명 확인", async () => {
      await expect(page).toHaveURL(/\/personal\/mypage$/);
      await expect(page.getByTestId("username")).toHaveText("user01");
    });
  });
});
```

---

✅ 이렇게 하면 HTML 구조에 맞추어 선택자가 안정적으로 동작할 수 있어요.  
👉 혹시 제가 **5개 성공 시나리오 전체 코드**(앞뒤 공백, 엔터 제출, 자동완성 포함)를 이 선택자들로 다 고쳐드릴까요?

---

**You:**

assertLoggedInToMyPage 함수에서 사용자명 선택자를 아래 html 구조를 보고 변경해줘
마이페이지에는 로그인한 사용자의 실명을 보여주고 있어

<section class="Mypage_mypage-info__eyAvx"><a href="/personal/media/profile"><span class="UserProfileImg_profile-photo__cos1v"><span class="Image_custom-image__JueAF Image_custom-image--fill__i6v0k"><img src="https://mc.albamon.kr/monimg/msa/assets/images/icon_profile_male80.svg" class="profile-photo__auto-image" alt=""></span></span></a><div class="mypage-info__user"><div class="mypage-info__user-name"><span class="Typography_typography__53V55 Typography_typography--H3__5ACir Typography_typography--bold__BbU7t">박진아<!-- -->님</span><a class="mypage-container__right" href="/personal/account"><button type="button" class="Button_button__S9rjD Button_text__5x_Cn Button_large___Kecx mypage-info__user-info-btn"><span class="button-inner"><i class="Icon_icon__BlZpj icon-system_setting"></i><span class="Typography_typography__53V55 Typography_typography--C1__LW8bB Typography_typography--regular__qCojp">회원정보</span></span></button></a></div><div class="mypage-info__resume"><a href="/personal/resume-register"><span class="Typography_typography__53V55 Typography_typography--C1__LW8bB Typography_typography--regular__qCojp mypage-info__accent-link">신규이력서 등록하기</span></a></div></div></section>

---

**ChatGPT:**

좋아요! 마이페이지 HTML을 보면 **실명 텍스트가 `section.Mypage_mypage-info__eyAvx` 내부의 `.mypage-info__user-name > span`** 에 들어가고, 표시 형식이 `박진아님`처럼 “이름 + 님”이에요.  
아래처럼 `assertLoggedInToMyPage` 함수를 **실명 기준**으로 검증하도록 수정하면 됩니다.

```ts
// utils/assertions.ts (예시)
// 기대 실명을 인자로 받아 "이름님" 패턴을 검증합니다.
import { expect, Page } from "@playwright/test";

export async function assertLoggedInToMyPage(page: Page, realName: string) {
  // URL 검증
  await expect(page).toHaveURL(/\/personal\/mypage$/);

  // 실명 요소 선택자 (마이페이지 헤더의 이름 영역)
  const nameEl = page.locator(
    "section.Mypage_mypage-info__eyAvx .mypage-info__user-name > span"
  );

  await expect(nameEl).toBeVisible();

  // "박진아님"처럼 '이름 + 님' 형태를 정규식으로 검증
  // 공백/개행이 끼어도 통과하도록 \s* 허용
  const expected = new RegExp(`^\\s*${realName}\\s*님\\s*$`);
  await expect(nameEl).toHaveText(expected);
}
```

사용 예시:

```ts
import { test } from "@playwright/test";
import { assertLoggedInToMyPage } from "../utils/assertions";

test("로그인 성공 시 마이페이지에서 실명이 노출되어야 함", async ({ page }) => {
  await page.goto("/user-account/login");
  await page.getByPlaceholder("아이디").fill("user01");
  await page.getByPlaceholder("비밀번호").fill("Pass123!");
  await page.getByRole("button", { name: "로그인" }).click();

  await assertLoggedInToMyPage(page, "박진아");
});
```

### 메모

- 클래스명이 빌드 시 해시처럼 바뀔 수 있다면(예: `Mypage_mypage-info__eyAvx`) 더 보수적으로  
   `section[class*="mypage-info"] .mypage-info__user-name > span` 같은 **부분 일치 선택자**로 완화할 수 있어요.
- 접근성 역할이 없다면 `getByRole` 대신 위처럼 **구체적인 구조 선택자** + **텍스트 정규식** 검증이 안전합니다.

---

# Playwright 테스트 작성 가이드

당신은 QA 전문가로 playwright로 테스트 코드를 작성합니다.
다음 가이드를 참고해서 테스트 코드를 작성해주세요.

## 테스트 파일 작성 규칙

### 기본 테스트 구조

ts
import { test, expect } from '@playwright/test';
import { TEST_USERS } from '../fixtures/users';

test.describe('인증 및 로그인 테스트', () => {
test.beforeEach(async ({ page }) => {
await page.goto('/login');
});

test('유효한 자격증명으로 로그인 시 대시보드로 이동', async ({ page }) => {
// 테스트 로직
});
});

## 테스트 케이스 작성 규칙

### 테스트 설명

ts
// ❌ 잘못된 예
test('login test', async ({ page }) => {});

// ✅ 좋은 예
test('유효한 이메일과 비밀번호로 로그인 시 대시보드로 이동해야 함', async ({ page }) => {});

### 테스트 단계 구분

ts
test('상품 구매 프로세스', async ({ page }) => {
await test.step('상품 페이지 진입', async () => {
await page.goto('/products/1');
await expect(page).toHaveURL('/products/1');
});

await test.step('장바구니에 추가', async () => {
await page.getByRole('button', { name: '장바구니 추가' }).click();
await expect(page.getByRole('alert')).toHaveText('장바구니에 추가되었습니다');
});
});

## Locator 전략

### 우선순위

ts
// 1. Role과 접근성 속성 (최우선)
page.getByRole('button', { name: '로그인' })
page.getByLabel('이메일')
page.getByRole('textbox', { name: '비밀번호' })
page.getByRole('heading', { name: '회원가입' })

// 2. 텍스트 및 기타
page.getByText('계정 만들기')
page.getByPlaceholder('이메일을 입력하세요')

// 3. 테스트 ID (Role과 접근성 속성으로 선택이 어려운 경우에 사용)
// ⚠️ 사용 전 반드시 해당 요소에 data-testid 속성이 정의되어 있는지 확인
page.getByTestId('submit-button')

// 안티 패턴
// ❌ 피해야 할 방식
page.locator('.login-btn')
page.locator('div > button')

## 검증(Assertions) 가이드

ts
// 요소 상태 검증
await expect(page.getByRole('button')).toBeEnabled();
await expect(page.getByRole('alert')).toBeVisible();

// 텍스트 검증
await expect(page.getByRole('heading')).toHaveText('환영합니다');

// URL 검증
await expect(page).toHaveURL(/.\*dashboard/);

// 다중 요소 검증
await expect(page.getByRole('listitem')).toHaveCount(3);

## 테스트 데이터 관리

ts
// tests/fixtures/users.ts
export const TEST_USERS = {
valid: {
email: 'test@example.com',
password: 'password123'
},
invalid: {
email: 'invalid@example.com',
password: 'wrong'
}
};

## 모킹 전략

다음과 같은 경우에만 API 모킹을 사용합니다:

- 외부 API 의존성이 있는 경우
- 테스트 환경에서 실제 API가 사용 불가능한 경우
- 특정 에러 상황 테스트가 필요한 경우

ts
// 특정 에러 상황 테스트를 위한 모킹 예시
test('API 에러 발생 시 에러 메시지 표시', async ({ page }) => {
await page.route('\*\*/api/users', route => {
route.fulfill({
status: 500,
contentType: 'application/json',
body: JSON.stringify({ error: '서버 오류가 발생했습니다.' })
});
});

await page.goto('/users');
await expect(page.getByRole('alert')).toHaveText('서버 오류가 발생했습니다.');
});

## 인증 상태 관리 (storageState)

### 인증이 필요한 테스트에서 사용

typescript
// tests/e2e/protected-route.spec.ts
import { test } from '@playwright/test';

test.use({ storageState: './tests/fixtures/auth.json' });

test('인증이 필요한 페이지 접근', async ({ page }) => {
await page.goto('/dashboard');
// ... 테스트 로직
});

---

**ChatGPT:**

아래는 **가이드를 반영해 다듬은 실패 시나리오 테스트**예요.  
핵심 개선점:

- `test.step`으로 단계 구분
- **접근성 우선 선택자**(`getByRole`, `getByPlaceholder`) 사용
- **클릭 ↔ alert 대기**를 `Promise.all`로 묶어 레이스 제거
- 로그인 URL은 **쿼리스트링 허용**(리다이렉트 파라미터 대응)
- 포커스/버튼 상태 등 **UI 상태 검증** 보강
- 타입 명시(`Page`) 및 중복 선택자 헬퍼 정리

```ts
// tests/login.failure.spec.ts
import { test, expect, Page } from "@playwright/test";

const CREDENTIALS = { id: "user01", pw: "Pass123!" };

const loginBtn = (page: Page) =>
  page.getByRole("button", { name: /^로그인$/, exact: true });

test.describe("인증 및 로그인 테스트 - 실패 시나리오", () => {
  test.beforeEach(async ({ page /*, context */ }) => {
    // 가이드: beforeEach에서는 진입 보장 위주로 간결하게
    await page.goto("/user-account/login");
    await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
    // 필요한 경우에만 주석 해제
    // await context.clearCookies();
    // await context.clearPermissions();
  });

  test("존재하지 않는 계정 → alert 노출 & 로그인 페이지 유지", async ({
    page,
  }) => {
    await test.step("입력", async () => {
      await page.getByPlaceholder("아이디").fill("no_user");
      await page.getByPlaceholder("비밀번호").fill("Any123!");
    });

    await test.step("로그인 시도 → alert 확인", async () => {
      const [dlg] = await Promise.all([
        page.waitForEvent("dialog"),
        loginBtn(page).click(),
      ]);
      await expect(dlg.message()).toContain(
        "아이디 또는 비밀번호가 올바르지 않습니다"
      );
      await dlg.accept();
    });

    await test.step("페이지/포커스 유지 확인", async () => {
      await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
      await expect(page.getByPlaceholder("아이디")).toBeFocused();
    });
  });

  test("비밀번호 불일치 → alert 노출, 비밀번호만 초기화 & 버튼 재활성화", async ({
    page,
  }) => {
    await test.step("입력", async () => {
      await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
      await page.getByPlaceholder("비밀번호").fill("Wrong999");
    });

    await test.step("로그인 시도 → alert 확인", async () => {
      const [dlg] = await Promise.all([
        page.waitForEvent("dialog"),
        loginBtn(page).click(),
      ]);
      await expect(dlg.message()).toContain(
        "아이디 또는 비밀번호가 올바르지 않습니다"
      );
      await dlg.accept();
    });

    await test.step("필드/버튼 상태 확인", async () => {
      await expect(page.getByPlaceholder("비밀번호")).toHaveValue("");
      await expect(loginBtn(page)).toBeEnabled();
    });
  });

  test("아이디 공란 → alert 노출, 아이디 포커스 & 요청 미발생(페이지 유지)", async ({
    page,
  }) => {
    await test.step("비밀번호만 입력", async () => {
      await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
    });

    await test.step("로그인 시도 → alert 확인", async () => {
      const [dlg] = await Promise.all([
        page.waitForEvent("dialog"),
        loginBtn(page).click(),
      ]);
      await expect(dlg.message()).toContain("아이디를 입력해주세요");
      await dlg.accept();
    });

    await test.step("페이지/포커스 유지", async () => {
      await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
      await expect(page.getByPlaceholder("아이디")).toBeFocused();
    });
  });

  test("비밀번호 공란 → alert 노출, 비밀번호 포커스 & 요청 미발생(페이지 유지)", async ({
    page,
  }) => {
    await test.step("아이디만 입력", async () => {
      await page.getByPlaceholder("아이디").fill(CREDENTIALS.id);
    });

    await test.step("로그인 시도 → alert 확인", async () => {
      const [dlg] = await Promise.all([
        page.waitForEvent("dialog"),
        loginBtn(page).click(),
      ]);
      await expect(dlg.message()).toContain("비밀번호를 입력해주세요");
      await dlg.accept();
    });

    await test.step("페이지/포커스 유지", async () => {
      await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
      await expect(page.getByPlaceholder("비밀번호")).toBeFocused();
    });
  });

  test("아이디 형식 위반 → 제출 차단: alert 또는 보조텍스트 노출", async ({
    page,
  }) => {
    await test.step("정책 위반 값 입력", async () => {
      // 예: 정책이 영숫자 4~16자 → 'ab'는 위반
      await page.getByPlaceholder("아이디").fill("ab");
      await page.getByPlaceholder("비밀번호").fill(CREDENTIALS.pw);
    });

    await test.step("로그인 시도 → 클라 검증 확인", async () => {
      const dialogPromise = page
        .waitForEvent("dialog", { timeout: 1200 })
        .catch(() => null);
      await loginBtn(page).click();

      const dlg = await dialogPromise;
      if (dlg) {
        await expect(dlg.message()).toMatch(/아이디 형식을 확인/i);
        await dlg.accept();
      } else {
        // 서비스 실제 에러 힌트 선택자로 교체 권장
        await expect(
          page.getByText(/아이디 형식을 확인|형식을 확인/i).first()
        ).toBeVisible();
      }
    });

    await test.step("네비게이션 차단 확인", async () => {
      await expect(page).toHaveURL(/\/user-account\/login(?:\?.*)?$/);
    });
  });
});
```

필요하면 동일한 패턴으로 **예외 시나리오(오프라인/500/타임아웃/스토리지 차단)** 도 이어서 작성해 드릴게요.

---
